
#### dependencyManagement

在Maven中dependencyManagement的作用其实相当于一个对所依赖jar包进行版本管理的管理器。

pom.xml文件中，jar的版本判断的两种途径

1. 如果dependencies里的dependency自己没有声明version元素，那么maven就会到dependencyManagement里面去找有没有对该artifactId和groupId进行过版本声明，如果有，就继承它，如果没有就会报错，告诉你必须为dependency声明一个version

2. 如果dependencies中的dependency声明了version，那么无论dependencyManagement中有无对该jar的version声明，都以dependency里的version为准。

    ```
    //只是对版本进行管理，不会实际引入jar  
    <dependencyManagement>  
        <dependencies>  
                <dependency>  
                    <groupId>org.springframework</groupId>  
                    <artifactId>spring-core</artifactId>  
                    <version>3.2.7</version>  
                </dependency>  
        </dependencies>  
    </dependencyManagement>  
    
    //会实际下载jar包  
    <dependencies>  
        <dependency>  
                    <groupId>org.springframework</groupId>  
                    <artifactId>spring-core</artifactId>  
        </dependency>  
    </dependencies>
    ```


## Scope的属性说明

scope定义了类包在项目的使用阶段。项目阶段包括： 编译，运行，测试和发布。

- **compile**: 默认scope为compile，表示为当前依赖参与项目的编译、测试和运行阶段，属于强依赖。打包之时，会达到包里去。
- **test**: 该依赖仅仅参与测试相关的内容，包括测试用例的编译和执行，比如定性的Junit。
- **runtime**: 依赖仅参与运行周期中的使用。一般这种类库都是接口与实现相分离的类库，比如JDBC类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的mysql、oracle等等数据的驱动程序。
此类的驱动都是为runtime的类库。
- **provided**: 该依赖在打包过程中，不需要打进去，这个由运行的环境来提供，比如tomcat或者基础类库等等，事实上，该依赖可以参与编译、测试和运行等周期，与compile等同。区别在于打包阶段进行了exclude操作。
- **system**: 使用上与provided相同，不同之处在于该依赖不从maven仓库中提取，而是从本地文件系统中提取，其会参照systemPath的属性进行提取依赖。
- **import** : 这个是maven2.0.9版本后出的属性，import只能在dependencyManagement的中使用，能解决maven单继承问题，import依赖关系实际上并不参与限制依赖关系的传递性。

### maven 引入本地jar包

> 当maven依赖本地而非repository中的jar包，sytemPath指明本地jar包路径。


1. 在pom.xml同级目录下新建lib文件夹，并放入本地jar包。
2. 配置Jar包的dependency，包括groupId，artifactId，version三个属性，同时还要包含scope和systemPath属性，分别指定Jar包来源于本地文件，和本地文件的所在路径。

    ```
    <dependency>
        <groupid>org.hamcrest</groupid>
        <artifactid>hamcrest-core</artifactid>
        <version>1.5</version>
        <scope>system</scope>
        <systempath>${basedir}/WebContent/WEB-INF/lib/hamcrest-core-1.3.jar</systempath>
    </dependency>
    ```

    如果是多模块项目，<systempath> 可以用当前 pom.xml 的方式导入本地jar包。

    POM文件里面可以引用一些内置属性(Maven预定义可以直接使用)  

    > ${basedir} 项目根目录   
    > ${version}表示项目版本;  
    > ${project.basedir}同${basedir};  
    > ${project.version}表示项目版本,与${version}相同;  
    > ${project.build.directory} 构建目录，缺省为target  
    > ${project.build.sourceEncoding}表示主源码的编码格式;  
    > ${project.build.sourceDirectory}表示主源码路径;  
    > ${project.build.finalName}表示输出文件名称;  
    > ${project.build.outputDirectory} 构建过程输出目录，缺省为target/classes  


3. 配置插件将本地jar包打入运行jar/war包中，由于scope=system,默认并不会将Jar包打进jar/war包中，所以需要通过插件进行打包。

    ```
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
        <version>2.10</version>
        <executions>
            <execution>
                <id>copy-dependencies</id>
                <phase>compile</phase>
                <goals>
                    <goal>copy-dependencies</goal>
                </goals>
                <configuration>
                    <outputDirectory>${project.build.directory}/${project.build.finalName}/WEB-INF/lib</outputDirectory>
                    <includeScope>system</includeScope>
                </configuration>
            </execution>
        </executions>
    </plugin>
    ```
    
    或者在项目根目录下运行，通过mvn install:install-file命令安装lib目录中的jar包到本地Maven仓库。
    ```
    mvn install:install-file -DgroupId=com.aliyun.mns -DartifactId=aliyun-sdk-mns -Dversion=1.1.8 -Dfile=lib/aliyun-sdk-mns-1.1.8.jar -Dpackaging=jar -DgeneratePom=true
    ```
    然后在项目POM.xml文件中引用。
    ```
    <dependency>
        <groupId>com.aliyun.mns</groupId>
        <artifactId>aliyun-sdk-mns</artifactId>
        <version>1.1.8</version>
    </dependency>
    ```

4. 将依赖jar包打包至jar包中

    方法一：

    ```
    <build>
            <finalName>包名</finalName>
            <plugins>
                <!--源码编译-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.7.0</version>
                    <configuration>
                        <source>1.8</source>
                        <target>1.8</target>
                    </configuration>
                </plugin>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-assembly-plugin</artifactId>
                    <version>2.4.1</version>
                    <configuration>
                        <appendAssemblyId>false</appendAssemblyId>
                        <descriptorRefs>
                            <descriptorRef>jar-with-dependencies</descriptorRef>
                        </descriptorRefs>
                        <archive>
                            <manifest>
                                <mainClass>包程序主类</mainClass>
                            </manifest>
                        </archive>
                    </configuration>
                    <executions>
                        <execution>
                            <id>make-assembly</id>
                            <phase>package</phase>
                            <goals>
                                <goal>assembly</goal>
                            </goals>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </build>
    ```

    方法二：生成含依赖xxx.jar包和original-xxx.jar不含依赖jar包。

    ```
    <build>
            <finalName>包名</finalName>
            <plugins>
                <!--源码编译-->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.7.0</version>
                    <configuration>
                        <source>1.8</source>
                        <target>1.8</target>
                    </configuration>
                </plugin>
                <!-- shade插件打包成jar包 -->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-shade-plugin</artifactId>
                    <version>3.1.1</version>
                    <executions>
                        <execution>
                            <phase>package</phase>
                            <goals>
                                <goal>shade</goal>
                            </goals>
                            <configuration>
                                <transformers>
                                    <transformer
            implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                        <mainClass>包程序主类</mainClass>
                                    </transformer>
                                </transformers>
                            </configuration>
                        </execution>
                    </executions>
                </plugin>         
            </plugins>
        </build>
    ```

# 参考

1. [Maven的Scope区别笔记](https://blog.csdn.net/blueheart20/article/details/81014116) . https://blog.csdn.net/blueheart20/article/details/81014116
1. [maven pom 引入本地jar包](https://www.cnblogs.com/lenovo_tiger_love/archive/2018/10/29/9873755.html) . https://www.cnblogs.com/lenovo_tiger_love/archive/2018/10/29/9873755.html
1. [Maven引入本地Jar包](https://www.jianshu.com/p/f50841f0963d) . https://www.jianshu.com/p/f50841f0963d